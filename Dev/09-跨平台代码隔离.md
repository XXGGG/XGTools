# 跨平台开发核心概念：代码隔离 (Code Isolation)

在开发像 Tauri 这样的跨平台桌面应用时，我们经常会遇到一个核心挑战：**不同操作系统的底层能力（API）是完全不同的**。

为了让同一套代码能在 Windows、macOS 和 Linux 上都能运行（至少能编译通过），我们需要使用**代码隔离**技术。

## 1. 什么是代码隔离？

代码隔离（在 Rust 中通常称为**条件编译**，Conditional Compilation）是指告诉编译器：
> "这段代码只在 Windows 下编译，那段代码只在 Mac 下编译。"

如果没有这种机制，当你在 Mac 上编译项目时，编译器会试图去寻找 Windows 的库（如 `windows` crate），结果找不到而报错，导致整个项目无法启动。


## 2. Rust 中的实现方式：`#[cfg(...)]`

Rust 使用 `#[cfg(...)]` 属性来实现这一功能。

### 示例代码

这是我们在 `src-tauri/src/lib.rs` 中实际使用的结构：

```rust
// 1. 引入依赖时的隔离
// 只有在 Windows 系统下，才引入 windows crate
#[cfg(target_os = "windows")] 
use windows::Win32::Foundation::{HWND, ...};

#[tauri::command]
fn enter_zen_mode(mode: String) {
    // 2. 逻辑实现的隔离
    
    // === Windows 专供代码 ===
    #[cfg(target_os = "windows")]
    unsafe {
        // 调用 Windows API 移动窗口
        let hwnd = GetForegroundWindow();
        // ... 具体实现 ...
    }

    // === macOS 专供代码 ===
    #[cfg(target_os = "macos")]
    {
        // 目前为空，或者打印提示
        println!("Zen Mode not yet implemented for macOS");
        // 未来在这里写 Mac 的 Accessibility API 代码
    }
    
    // === Linux 专供代码 ===
    #[cfg(target_os = "linux")]
    {
        println!("Zen Mode not yet implemented for Linux");
    }
}
```

### ✅ 需要重写的部分（OS 特有功能）
凡是涉及**操作系统底层能力**的功能，必须针对每个平台单独开发。例如：
*   **截图**：Windows 用 GDI/DirectX，Mac 用 ScreenCaptureKit。**（需要开发两次）**
*   **系统托盘**：虽然 Tauri 封装好了，但底层实现其实是分开的。

### ❌ 不需要重写的部分（通用逻辑）
凡是**业务逻辑**或**Web 前端**，只需要写一次。例如：
*   **Vue 界面**：你的按钮、样式、暗黑模式切换，在所有平台上都是通用的。**（写一次，到处运行）**
*   **纯计算逻辑**：比如“计算两个数的和”，或者“解析 JSON 数据”，Rust 代码也是通用的。
*   **Tauri 封装好的插件**：比如 `tauri-plugin-autostart`（开机自启），插件作者已经帮你把 Windows 和 Mac 的脏活累活都干完了，你只需要调用 `enable()`，它在不同系统下会自动执行不同的底层代码。

### 总结
**Tauri 的伟大之处**在于，它把 90% 的通用工作（UI、网络、文件系统）都封装好了，让你只需要关注那 10% 真正需要“因地制宜”的特殊功能。
