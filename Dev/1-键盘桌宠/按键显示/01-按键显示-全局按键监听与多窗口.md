# 全局按键监听与多窗口 (按键显示器)

## 1. 原理分析

我们需要两个核心能力：
1.  **全局监听 (Global Listener)**: 无论应用是否在最前端，都能听到键盘的声音。这需要 Rust 后端支持 (`rdev` 库)。
2.  **多窗口架构 (Multi-window)**: 主窗口用来管理设置，副窗口用来显示按键。副窗口需要是透明、置顶且无边框的。

## 2. 后端实现：安装耳朵 (Rust)

首先，我们需要给 Rust 安装一个库来监听输入。

### 2.1 添加依赖 (`src-tauri/Cargo.toml`)
在 `src-tauri/Cargo.toml` 中添加 `rdev`：

```toml
[dependencies]
rdev = "0.5" # 用于全局键盘/鼠标监听
```

### 2.2 编写监听逻辑 (`src-tauri/src/lib.rs`)

我们需要在后台开启一个线程，专门负责“听”按键，听到后通过 `app.emit` 广播告诉前端。

```rust
use std::thread;
use rdev::{listen, EventType};
use tauri::Emitter; // 记得引入这个

// 定义发送给前端的数据结构
#[derive(serde::Serialize, Clone)]
struct InputPayload {
    event_type: String,
    key: String,
}

// 初始化监听器函数
fn init_input_listener(app: tauri::AppHandle) {
    thread::spawn(move || {
        // listen 会阻塞当前线程，所以必须放在 thread::spawn 里
        if let Err(error) = listen(move |event| {
            let payload = match event.event_type {
                // KeyPress 是按键按下事件，我们监听它
                EventType::KeyPress(key) => Some(InputPayload {
                    event_type: "KeyPress".to_string(),
                    key: format!("{:?}", key), // 格式化为 KeyA, Num1 等
                }),
                // KeyRelease 是按键释放事件，我们也监听它
                EventType::KeyRelease(key) => Some(InputPayload {
                    event_type: "KeyRelease".to_string(),
                    key: format!("{:?}", key),
                }),
                // 我们也可以监听鼠标，但为了性能，这里只演示按键
                EventType::ButtonPress(btn) => Some(InputPayload {
                    event_type: "ButtonPress".to_string(),
                    key: format!("{:?}", btn),
                }),
                // ButtonRelease 是鼠标按钮释放事件，我们也监听它
                EventType::ButtonRelease(btn) => Some(InputPayload {
                    event_type: "ButtonRelease".to_string(),
                    key: format!("{:?}", btn),
                }),
                _ => None,
            };
            
            if let Some(p) = payload {
                // 发送事件给所有窗口
                let _ = app.emit("input-event", p);
            }
        }) {
            println!("Error: {:?}", error);
        }
    });
}
```

最后在 `lib.rs` 的 `setup` 钩子里调用它：

```rust
.setup(|app| {
    init_input_listener(app.handle().clone());
    // ... 其他代码
})
```


## 3. 前端实现：配置副窗口 (Tauri)

我们需要在 `tauri.conf.json` 里定义这个特殊的窗口。

### 3.1 窗口配置 (`tauri.conf.json`)
找到 `app.windows` 数组，添加一个新的窗口配置：

```json
{
  "label": "key_visualizer",// 唯一标识符
  "title": "KeyVisualizer", // 窗口标题
  "url": "index.html",      // 副窗口加载的 HTML 文件
  "width": 270,
  "height": 300,
  "decorations": false,     // 无边框
  "shadow": false,          // 无阴影
  "transparent": true,      // 透明背景
  "alwaysOnTop": true,      // 总是置顶
  "skipTaskbar": true,      // 不在任务栏显示
  "resizable": false,       // 禁止调整大小
  "visible": false          // 默认隐藏，由我们代码控制显示
}
```

### 3.2 权限配置 (`capabilities/default.json`)
`src-tauri/capabilities/default.json`
为了让代码能控制窗口位置和显示隐藏，我们需要添加权限：

```json
{
  "windows": ["main", "key_visualizer"],
  "permissions": [
    "core:window:allow-set-position",
    "core:window:allow-outer-position",
    "core:window:allow-current-monitor",
    "core:window:allow-show",
    "core:window:allow-hide",
    "core:window:allow-set-focus",
    "core:window:allow-set-ignore-cursor-events"
  ]
}
```
原理说明：

- "windows": ["main", "key_visualizer"] : 告诉 Tauri，这些权限规则同时适用于主窗口和副窗口。没有这一步，副窗口就像一个没有灵魂的网页，无法调用 Rust 后端。
- allow-show / allow-hide : 允许代码调用 win.show() 和 win.hide() 。
- allow-set-ignore-cursor-events : 允许副窗口设置“鼠标穿透”（即透明部分不响应鼠标点击），这是按键显示悬浮窗的核心功能。


## 4. 前端实现：UI 与逻辑 (Vue)

### 4.1 路由分发 (`App.vue`)
因为我们是单页应用 (SPA)，主窗口和副窗口加载的都是 `index.html`。我们需要根据窗口的 `label` 来决定显示什么内容。

```typescript
import { ref, onMounted } from 'vue'; //添加onMounted
// ....
import { getCurrentWindow } from '@tauri-apps/api/window';
import KeyVisualizerWindow from './KeyVisualizerWindow.vue';

import HomeView from './views/Home.vue';
import KeyboardPetView from './views/KeyboardPet.vue';//【页面】键盘桌宠

//...

const isKeyVisualizer = ref(false);

onMounted(async () => {
  const win = getCurrentWindow();
  if (win.label === 'key_visualizer') {
    isKeyVisualizer.value = true;
    return; // 如果是副窗口，就只做副窗口该做的事
  }
  // ... 主窗口逻辑
});
```

模板中：

```vue
<template>
  <KeyVisualizerWindow v-if="isKeyVisualizer" />
  <div v-else>
    <!-- 主程序界面 -->
    <HomeView v-if="currentView === 'Home'" />
    <KeyboardPetView v-else-if="currentView === 'KeyboardPet'" />
  </div>
</template>
```

### 4.2 按键显示组件 (`KeyVisualizerWindow.vue`)

这个组件负责接收 Rust 发来的消息，并展示为“堆栈”效果。

```vue
<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue';
import { listen } from '@tauri-apps/api/event';
import { getCurrentWindow } from '@tauri-apps/api/window';


// 定义输入事件负载接口
interface InputPayload {
    event_type: string;
    key: string;
}

// 定义按键项接口
interface KeyItem {
    id: number;
    key: string;
    timestamp: number;
}

const keys = ref<KeyItem[]>([]); // 按键项列表
let nextId = 0; // 下一个按键项的唯一 ID 计数器
let unlisten: (() => void) | null = null;// 事件监听取消函数
let unlistenConfig: (() => void) | null = null; // 配置监听取消函数
const isEditMode = ref(false);// 是否编辑模式

// 配置
const MAX_ITEMS = 4; // 最大显示按键项数量

// 按键映射表 (在这里修改别名)
// 格式: '原始键名': '显示名称'
const keyMap: Record<string, string> = {
    // 修饰键
    'ControlLeft': 'Ctrl',
    'ControlRight': 'Ctrl',
    'ShiftLeft': 'Shift',
    'ShiftRight': 'Shift',
    'Alt': 'Alt',
    'AltGr': 'Alt',
    'MetaLeft': 'Win',
    'MetaRight': 'Win',
    // 兼容带 Key 前缀的情况 (防止 rdev 版本差异导致识别失败)
    'KeyControlLeft': 'Ctrl',
    'KeyControlRight': 'Ctrl',
    'KeyShiftLeft': 'Shift',
    'KeyShiftRight': 'Shift',
    'KeyAlt': 'Alt',
    'KeyMetaLeft': 'Win',
    'KeyMetaRight': 'Win',

    // 常用功能键
    'Space': 'Space',
    'Return': 'Enter',
    'Escape': 'Esc',
    'Backspace': 'Backspace',
    'Tab': 'Tab',
    'CapsLock': 'Caps',
    'Delete': 'Del',
    'Home': 'Home',
    'End': 'End',
    'PageUp': 'PgUp',
    'PageDown': 'PgDn',
    'Insert': 'Ins',
    'PrintScreen': 'PrtSc',
    'ScrollLock': 'ScrlLk',
    'Pause': 'Pause',
    'NumLock': 'Num',

    // 方向键
    'UpArrow': '↑',
    'DownArrow': '↓',
    'LeftArrow': '←',
    'RightArrow': '→',

    // rdev 可能是 Up/Down/Left/Right
    'Up': '↑',
    'Down': '↓',
    'Left': '←',
    'Right': '→',

    // 符号
    'Dot': '.',
    'Comma': ',',
    'SemiColon': ';',
    'Quote': "'",
    'LeftBracket': '[',
    'RightBracket': ']',
    'BackSlash': '\\',
    'Slash': '/',
    'Minus': '-',
    'Equal': '=',
    'BackQuote': '`',
};

// 状态跟踪
const activeModifiers = ref<Set<string>>(new Set());
// 标记修饰键按下期间是否有其他键按下
const modifierDirty = ref<Record<string, boolean>>({});

// 辅助函数：获取显示名称
const getDisplayName = (rawKey: string): string => {
    if (keyMap[rawKey]) return keyMap[rawKey];
    // 处理 F1-F12
    if (/^KeyF\d+$/.test(rawKey)) return rawKey.replace('Key', '');
    // 处理数字 Digit0-9
    if (/^Digit\d$/.test(rawKey)) return rawKey.replace('Digit', '');
    // 处理字母 KeyA-KeyZ
    if (/^Key[A-Z]$/.test(rawKey)) return rawKey.replace('Key', '');
    // 处理小键盘 Num1-Num9
    if (/^Num\d$/.test(rawKey)) return rawKey.replace('Num', '');

    // 默认处理
    return rawKey.replace('Key', '');
};

// 辅助函数：判断是否为修饰键
const isModifier = (key: string): boolean => {
    return ['Ctrl', 'Shift', 'Alt', 'Win'].includes(key);
};

// 辅助函数：添加按键到显示列表
const addKeyToDisplay = (displayText: string) => {
    // 如果是重复的最后一个按键，可能只想更新时间或不做处理？
    // 这里我们简单点，每次都加新的，顶掉旧的
    keys.value.unshift({
        id: nextId++,
        key: displayText,
        timestamp: Date.now()
    });

    if (keys.value.length > MAX_ITEMS) {
        keys.value.pop();
    }
};

onMounted(async () => {

    // 强制设置透明背景
    document.documentElement.style.backgroundColor = 'transparent';
    document.body.style.backgroundColor = 'transparent';

    const win = getCurrentWindow();// 获取当前窗口实例

    try {
        // 默认开启鼠标穿透 (忽略鼠标事件)
        await win.setIgnoreCursorEvents(true);
    } catch (e) {
        console.error('setIgnoreCursorEvents failed:', e);
    }


    // 监听配置变更事件
    unlistenConfig = await listen('toggle-key-visualizer-edit', async (event: any) => {
        const enabled = event.payload;
        isEditMode.value = enabled;
        // 如果是编辑模式，不忽略鼠标 (可以点击/拖拽)
        // 如果是正常模式，忽略鼠标 (穿透)
        await win.setIgnoreCursorEvents(!enabled);

        if (enabled) {
            // 编辑模式下，显示并置顶，确保用户能看到
            await win.show();
            await win.setFocus();
        } else {
        }
    });

    // 监听输入事件
    unlisten = await listen<InputPayload>('input-event', (event) => {
        // console.log('Received input-event:', event.payload); // 打印原始事件
        // event_type: KeyPress/KeyRelease/ButtonPress
        // key: 原始按键名称 (如 KeyA, KeyF1, Digit0, etc.)
        const { event_type, key } = event.payload; 
        // 转换为显示名称 (如 KeyA -> A, KeyF1 -> F1, Digit0 -> 0)
        const displayName = getDisplayName(key);

        
        // 按键事件处理 KeyPress 意思是【按键按下】
        if (event_type === 'KeyPress') {
            // 【处理组合按钮，例如 Ctrl+A，Ctrl+Alt+A】
            if (isModifier(displayName)) {
                // 修饰键（Ctrl/Shift/Alt/Win）按下
                // 只在首次按下时添加到 activeModifiers
                if (!activeModifiers.value.has(displayName)) {
                    activeModifiers.value.add(displayName);
                    modifierDirty.value[displayName] = false; // 只有首次按下重置状态
                }
            } else {
                // 普通按键按下
                // 标记所有当前按下的修饰键为 dirty (已使用)
                activeModifiers.value.forEach(m => modifierDirty.value[m] = true);

                // 构建组合字符串
                // 顺序：Ctrl -> Shift -> Alt -> Win -> Key
                const combo: string[] = [];
                if (activeModifiers.value.has('Ctrl')) combo.push('Ctrl');
                if (activeModifiers.value.has('Shift')) combo.push('Shift');
                if (activeModifiers.value.has('Alt')) combo.push('Alt');
                if (activeModifiers.value.has('Win')) combo.push('Win');

                combo.push(displayName); //最后连接普通按键
                addKeyToDisplay(combo.join(' + '));//用 + 号连接，例如：Ctrl + A
            }
        } else if (event_type === 'KeyRelease') {//【处理按键释放事件】
            if (isModifier(displayName)) { //如果是修饰键
                // 如果修饰键释放，且期间没有被使用过（没有与其他键组合），则单独显示
                if (modifierDirty.value[displayName] === false) {
                    addKeyToDisplay(displayName);
                }
                activeModifiers.value.delete(displayName);
                delete modifierDirty.value[displayName];
            }
        } else if (event_type === 'ButtonPress') {//【处理鼠标按键事件】
            // 鼠标按键
            let mouseKey = key;
            if (key === 'Left') mouseKey = '左键';
            if (key === 'Right') mouseKey = '右键';
            if (key === 'Middle') mouseKey = '中键';

            // 鼠标也可以配合修饰键
            const combo: string[] = [];
            if (activeModifiers.value.has('Ctrl')) combo.push('Ctrl');
            if (activeModifiers.value.has('Shift')) combo.push('Shift');
            if (activeModifiers.value.has('Alt')) combo.push('Alt');
            if (activeModifiers.value.has('Win')) combo.push('Win');

            combo.push(mouseKey);
            addKeyToDisplay(combo.join(' + '));
        }
    });
});

// 组件卸载时，移除事件监听
onUnmounted(() => {
    if (unlisten) unlisten(); //移除输入事件监听
    if (unlistenConfig) unlistenConfig(); //移除配置变更事件监听
});
</script>



<template>
    <!-- 
    根容器
    isEditMode=true: 显示背景，允许鼠标事件 (pointer-events-auto)
    isEditMode=false: 透明背景，禁止鼠标事件 (pointer-events-none)
  -->
    <div class="h-full w-full flex flex-col-reverse items-end p-0 overflow-hidden transition-colors duration-300 relative"
        :class="{
            'bg-black border-2 border-dashed border-yellow-400 pointer-events-auto': isEditMode,
            'bg-transparent pointer-events-none': !isEditMode
        }">
        <!-- 拖拽区域：仅在编辑模式下存在，覆盖全屏 -->
        <div v-if="isEditMode" data-tauri-drag-region class="absolute inset-0 z-0 cursor-move"></div>

        <!-- 提示文字 -->
        <div v-if="isEditMode" class="absolute top-2 left-2 text-yellow-400 font-bold text-xs pointer-events-none z-10">
            Drag to Move
        </div>

        <!-- 按键列表容器 (z-10 确保在拖拽层之上) -->
        <TransitionGroup name="list" tag="div"
            class="flex flex-col-reverse items-end w-full z-10 pointer-events-none pb-2 pr-2">
            <div v-for="(item, index) in keys" :key="item.id" class="mb-2 transition-all duration-300" :class="{
                'opacity-100 scale-100': index === 0,
                'opacity-70 scale-90': index === 1,
                'opacity-40 scale-80': index === 2,
                'opacity-10 scale-75': index >= 3
            }">
                <div
                    class="bg-black/70 text-white px-4 py-2 rounded-lg backdrop-blur-sm font-mono font-bold text-xl border border-white/10">
                    {{ item.key }}
                </div>
            </div>
        </TransitionGroup>
    </div>
</template>

<style scoped>
.list-move,
.list-enter-active,
.list-leave-active {
    transition: all 0.3s ease;
}

.list-enter-from {
    opacity: 0;
    transform: translateY(20px);
}

.list-leave-to {
    opacity: 0;
    transform: translateY(-20px);
}

/* 确保列表项在移动时绝对定位，实现平滑过渡 */
.list-leave-active {
    position: absolute;
}
</style>
```



### 4.3 KeyboardPet.vue

```vue
<script setup lang="ts">
import { ref, onMounted } from 'vue';
import { WebviewWindow } from '@tauri-apps/api/webviewWindow';
import { emit } from '@tauri-apps/api/event';
// import { LazyStore } from '@tauri-apps/plugin-store';
import { LogicalSize } from '@tauri-apps/api/window';

const isKeyVisOpen = ref(false); // 是否打开按键可视化窗口
const isEditMode = ref(false);  // 是否编辑模式
// const store = new LazyStore('settings.json');

// 切换编辑模式
const toggleEditMode = async () => {
    isEditMode.value = !isEditMode.value;
    await emit('toggle-key-visualizer-edit', isEditMode.value);
};

// 重置窗口位置
const resetWindowPosition = async () => {
    try {
        const win = await WebviewWindow.getByLabel('key_visualizer');
        if (win) {
            // 1. 检查是否被最小化，如果是则恢复
            if (await win.isMinimized()) {
                await win.unminimize();
            }

            // 2. 确保窗口可见
            if (!(await win.isVisible())) {
                await win.show();
            }

            // 3. 强制恢复默认尺寸 (270x300)
            await win.setSize(new LogicalSize(270, 300));

            // 4. 发送重置位置事件 (让窗口自己移动到右下角)
            await emit('reset-key-visualizer-position');
        }
    } catch (error) {
        console.error('Failed to reset position:', error);
    }
};

// 检查窗口状态并同步配置
const checkWindowState = async () => {
    // 1. 初始化 store
    // await store.init();

    // 2. 获取保存的配置
    // const savedState = await store.get<boolean>('key_visualizer_enabled');

    // 3. 检查当前窗口是否真的存在
    const win = await WebviewWindow.getByLabel('key_visualizer');
    if (win) {
        isKeyVisOpen.value = await win.isVisible();
    }

    // 4. 如果配置是开启的，但窗口没开 (比如应用刚启动)，则自动开启
    // if (savedState && !isKeyVisOpen.value) {
    //     console.log('Auto-opening Key Visualizer based on saved settings...');
    //     await toggleKeyVis();
    // }
};

onMounted(() => {
    checkWindowState();
});

// 切换按键可视化窗口
const toggleKeyVis = async () => {
    try {
        let win = await WebviewWindow.getByLabel('key_visualizer');

        if (!win) {
            // 动态创建窗口
            win = new WebviewWindow('key_visualizer', {
                url: 'index.html',
                title: 'key_visualizer',
                width: 270,
                height: 300,
                decorations: false,
                shadow: false,
                transparent: true,
                alwaysOnTop: true,
                skipTaskbar: true,
                resizable: false,
                visible: true
            });

            // 监听创建错误
            win.once('tauri://error', (e) => {
                console.error('Failed to create window:', e);
                alert('无法创建按键显示窗口，请尝试重启应用。' + JSON.stringify(e));
            });

            // 监听创建完成事件
            win.once('tauri://created', () => {
                console.log('[Pet.vue] Window created event received');
            });

            // 重置编辑模式
            isEditMode.value = false;
            // 同步编辑模式到窗口
            await emit('toggle-key-visualizer-edit', false);

            // 窗口打开状态
            isKeyVisOpen.value = true;
            // 保存状态
            // await store.set('key_visualizer_enabled', true);
            // await store.save();
            return;
        }

        // 如果窗口可见
        if (isKeyVisOpen.value) {
            // 那么久把窗口关闭
            await win.hide();
            isKeyVisOpen.value = false;

            // 关闭时也重置编辑模式
            isEditMode.value = false;
            await emit('toggle-key-visualizer-edit', false);

            // 保存状态
            // await store.set('key_visualizer_enabled', false);
            // await store.save();
        } else {
            // 否则窗口就打开
            await win.show();
            isKeyVisOpen.value = true;
            // await win.setFocus(); // 确保窗口获得焦点
            // await win.center(); // 强制居中，防止跑偏 (已移除，避免影响位置恢复)

            // 窗口打开时默认关闭编辑模式
            isEditMode.value = false;
            await emit('toggle-key-visualizer-edit', false);

            
            // 调试提示
            const isVisible = await win.isVisible();
            if (!isVisible) {
                alert('警告：窗口已调用 show() 但 isVisible 仍为 false。请检查 tauri.conf.json 配置。');
            }

            // 保存状态
            // await store.set('key_visualizer_enabled', true);
            // await store.save();
        }
    } catch (error) {
        console.error('Toggle error:', error);
        alert('操作失败: ' + String(error));
    }
};
</script>

<template>
    <div class="h-full w-full p-8 flex flex-col space-y-4">
        <!-- 极简版按键显示控制 -->
        <div class="w-full max-w-2xl mx-auto bg-card border rounded-xl p-4 flex items-center justify-between shadow-sm">
            <div class="flex items-center gap-4">
                <div class="flex p-2 bg-primary/10 rounded-lg text-primary">
                    <span class="icon-[lucide--keyboard] w-6 h-6" />
                </div>
                <span class="font-bold text-lg">按键显示</span>
            </div>

            <div class="flex items-center gap-2">
                <!-- 重置位置按钮 (仅开启时显示) -->
                <button v-if="isKeyVisOpen" @click="resetWindowPosition"
                    class="flex p-2 rounded-lg transition-colors hover:bg-accent text-muted-foreground hover:text-foreground"
                    title="重置位置">
                    <span class="icon-[lucide--rotate-ccw] w-6 h-6" />
                </button>

                <!-- 移动/调整位置按钮 (仅开启时显示) -->
                <button v-if="isKeyVisOpen" @click="toggleEditMode" class="flex p-2 rounded-lg transition-colors"
                    :class="isEditMode ? 'bg-yellow-500 text-white hover:bg-yellow-600' : 'hover:bg-accent text-muted-foreground hover:text-foreground'"
                    title="调整位置">
                    <span class="icon-[lucide--move] w-6 h-6" />
                </button>

                <!-- 开关按钮 -->
                <button @click="toggleKeyVis" class="flex p-2 rounded-lg transition-colors"
                    :class="isKeyVisOpen ? 'text-primary hover:bg-primary/10' : 'text-muted-foreground hover:text-foreground hover:bg-accent'"
                    :title="isKeyVisOpen ? '关闭显示' : '开启显示'">
                    <span :class="isKeyVisOpen? 'icon-[lucide--eye]' : 'icon-[lucide--eye-off]'" class="w-6 h-6" />
                </button>
            </div>
        </div>

        <!-- 桌宠区域 (占满剩余空间) -->
        <div
            class="w-full max-w-2xl mx-auto flex-1 bg-card border rounded-xl p-8 flex flex-col items-center justify-center space-y-6 shadow-sm opacity-60">
            <div class="flex p-6 bg-muted rounded-full text-muted-foreground">
                <span class="icon-[lucide--cat] w-20 h-20" />
            </div>
            <div class="text-center space-y-2">
                <h3 class="font-bold text-2xl">键盘桌宠</h3>
                <p class="text-muted-foreground">
                    可爱的键盘桌宠，即将来袭。
                </p>
            </div>
            <button disabled
                class="px-8 py-3 bg-muted text-muted-foreground rounded-full font-medium cursor-not-allowed">
                开发中...
            </button>
        </div>
    </div>
</template>

```




























## 5. 控制开关

在主界面（比如桌宠页），我们可以通过 `WebviewWindow.getByLabel('key_visualizer')` 来获取窗口句柄，控制它的显示和隐藏。

```typescript
import { WebviewWindow } from '@tauri-apps/api/webviewWindow';

const toggle = async () => {
  const win = await WebviewWindow.getByLabel('key_visualizer');
  if (win) {
     // 切换显示/隐藏
  }
};
```