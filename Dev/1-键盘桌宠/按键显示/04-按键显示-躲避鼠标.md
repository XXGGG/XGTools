# 按键显示窗口 躲避鼠标

## 先创建一个是否要躲避的按键
`KeyboardPet.vue`

```typescript
const isAvoidMouse = ref(false); // 是否躲避鼠标

// 切换躲避鼠标
const toggleAvoidMouse = async () => {
    // 发送躲避事件
    isAvoidMouse.value = !isAvoidMouse.value;
    await emit('toggle-avoid-mouse', isAvoidMouse.value);
    // 6. 同步配置到 store
    await store.set('avoid_mouse', isAvoidMouse.value);
};

// 检查窗口状态并同步配置
const checkWindowState = async () => {
    // 1. 初始化 store
    await store.init();

    // ....

    // 5. 是否有开启躲避鼠标
    isAvoidMouse.value = await store.get<boolean>('avoid_mouse') || false;    
};
```

```html
<!-- 躲避按钮 (仅开启时显示) -->
<button v-if="isKeyVisOpen" @click="toggleAvoidMouse" class="flex p-2 rounded-lg transition-colors"
    :class="isAvoidMouse ? 'bg-yellow-500 text-white hover:bg-yellow-600' : 'hover:bg-accent text-muted-foreground hover:text-foreground'"
    title="躲避鼠标">
    <span class="icon-[lucide--square-dashed-mouse-pointer] w-6 h-6" />
</button>
```

这样在 KeyboardPet 就可以知道是否要躲避鼠标了
然后把 isAvoidMouse 传递给 KeyVisualizerWindow.vue
在 KeyVisualizerWindow.vue 中使用store来获取是否要躲避鼠标

## KeyVisualizerWindow.vue
```typescript
const isAvoidMouse = ref(false);// 是否躲避鼠标


onMounted(async () => {

    // 初始化 Store
    await store.init();

    // 是否要躲避鼠标
    isAvoidMouse.value = await store.get('avoid_mouse') || false;

    //.....
})
```


然后创建一个全局窗口覆盖整个窗口，

1. 当 isAvoidMouse 为 true 时 且
2. 不在编辑模式下，isEditMode 为 false时
改全局覆盖窗口出现。该覆盖层要全透明，在最顶层。

检测鼠标移入。
当鼠标移入时，判断范围，自动启动智能布局。
### 监听鼠标取消函数
```typescript
let unlistenAvoidMouse: (() => void) | null = null; // 避免鼠标监听取消函数

// 是否要躲避鼠标
isAvoidMouse.value = await store.get('avoid_mouse') || false;
unlistenAvoidMouse = await listen('toggle-avoid-mouse', async (event: any) => {
    const enabled = event.payload;
    isAvoidMouse.value = enabled;

    // 如果开启躲避鼠标，就不要穿透
    await win.setIgnoreCursorEvents(!enabled);
    if (isEditMode.value) {
        // 如果关闭躲避鼠标，就穿透鼠标
        await win.setIgnoreCursorEvents(!isEditMode.value);
    }
});
try {
    // 默认开启鼠标穿透 (忽略鼠标事件)
    if (!isAvoidMouse.value) {
        console.log('开启鼠标穿透 (忽略鼠标事件)');
        await win.setIgnoreCursorEvents(true);
    }else {
        console.log('关闭鼠标穿透 (不忽略鼠标事件)');
        await win.setIgnoreCursorEvents(false);
    }
} catch (e) {
    console.error('setIgnoreCursorEvents failed:', e);
}

// 监听配置变更事件
unlistenConfig = await listen('toggle-key-visualizer-edit', async (event: any) => {
    const enabled = event.payload;
    isEditMode.value = enabled;
    // 如果是编辑模式，不忽略鼠标 (可以点击/拖拽)
    // 如果是正常模式，忽略鼠标 (穿透)
    await win.setIgnoreCursorEvents(!enabled);
    if (isAvoidMouse.value && !enabled) {
        // 如果没有在编辑模式 ，且 开启了躲避鼠标
        await win.setIgnoreCursorEvents(false);
    }

    if (enabled) {
        // 编辑模式下，显示并置顶，确保用户能看到
        await win.show();
        await win.setFocus();
    } else {
        // 退出编辑模式时，保存位置
        await saveWindowPosition(); //添加这一行，确保退出编辑模式时保存位置
    }
});





onUnmounted(() => {
    //...
    if (unlistenAvoidMouse) unlistenAvoidMouse(); //移除避免鼠标事件监听
});
```

### 全窗口覆盖层HTML
```html
<div v-if="isAvoidMouse && !isEditMode" @mouseover="handleMouseEnter" 
    class="absolute top-0 left-0 right-0 bottom-0 bg-black z-100">
</div>
```

### 监听鼠标移入函数
```typescript
// 四个角落的判断范围
const handleMouseEnter = () => {
    if (isAvoidMouse.value && !isEditMode.value) {
        // 鼠标移入时，判断范围，自动启动智能布局
        console.log('鼠标移入时，判断范围，自动启动智能布局');
        console.log('layoutMode.value', layoutMode.value);
        if (layoutMode.value === 'left-bottom') {
            updateWindowPosition('right-bottom');//从左边去右边
        } else if (layoutMode.value === 'right-bottom') {
            updateWindowPosition('left-bottom');//从右边去左边
        } else if (layoutMode.value === 'left-top') {
            updateWindowPosition('right-top');//从左边去右边
        } else if (layoutMode.value === 'right-top') {
            updateWindowPosition('left-top');//从右边去左边
        }
    }
}

// 辅助函数：更新窗口位置 (右下角)
const updateWindowPosition = async (mode: LayoutMode = layoutMode.value) => {
    const win = getCurrentWindow(); // 获取当前窗口实例
    const monitor = await currentMonitor(); // 获取当前窗口所在的屏幕

    if (monitor) {
        const scaleFactor = monitor.scaleFactor; // 获取屏幕缩放因子
        const logicalScreenWidth = monitor.size.width / scaleFactor;
        const logicalScreenHeight = monitor.size.height / scaleFactor;
        const winWidth = 270;
        const winHeight = 300;

        let x = logicalScreenWidth - winWidth - PADDING;
        let y = logicalScreenHeight - winHeight - PADDING - 60;
        if(mode === 'left-bottom'){
            x = PADDING;
            y = logicalScreenHeight - winHeight - PADDING - 60;
        }
        else if(mode === 'right-bottom'){
            x = logicalScreenWidth - winWidth - PADDING;
            y = logicalScreenHeight - winHeight - PADDING - 60;
        }
        else if(mode === 'left-top'){
            x = PADDING;
            y = PADDING;
        }
        else if(mode === 'right-top'){
            x = logicalScreenWidth - winWidth - PADDING;
            y = PADDING;
        }   

        await win.setPosition(new LogicalPosition(x, y));
    }
};
```