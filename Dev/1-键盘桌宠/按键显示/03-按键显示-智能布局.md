# 教程：按键显示窗口的智能布局升级

## 前言

在这个教程中，我们将一步一步地为 `KeyVisualizerWindow.vue`（按键显示窗口）添加一个很酷的功能：

**让按键显示根据窗口在屏幕上的位置，自动调整显示方向和对齐方式。**

比如：
- 窗口在**右下角**时：按键从下往上显示，靠右对齐（默认）
- 窗口在**左下角**时：按键从下往上显示，靠左对齐
- 窗口在**右上角**时：按键从上往下显示，靠右对齐
- 窗口在**左上角**时：按键从上往下显示，靠左对齐

这样用户无论把窗口放在哪里，按键都会以最合适的方式显示出来！

---

## 第一步：定义布局模式

首先，我们需要告诉程序有哪些布局模式。

### 1.1 找到配置区域

打开 `src/KeyVisualizerWindow.vue`，找到这部分代码：

```typescript
const isEditMode = ref(false);
const store = new LazyStore('settings.json');

// 配置
const MAX_ITEMS = 4;
const PADDING = 20;
```

### 1.2 添加布局模式的定义

在 `PADDING = 20;` 的下面，添加以下代码：

```typescript
// 布局模式：根据窗口在屏幕上的位置决定
// left-bottom: 从下往上，靠左
// right-bottom: 从下往上，靠右 (默认)
// left-top: 从上往下，靠左
// right-top: 从上往下，靠右
type LayoutMode = 'left-bottom' | 'right-bottom' | 'left-top' | 'right-top';
const layoutMode = ref<LayoutMode>('right-bottom');
```

### 解释一下

- `type LayoutMode` 定义了4种可能的布局模式
- `layoutMode` 是一个响应式变量，用来存储当前的布局模式
- 默认值是 `'right-bottom'`，因为窗口默认在右下角

---

## 第二步：创建布局检测函数

现在我们需要一个函数，用来检测窗口在屏幕的哪个位置，然后设置对应的布局模式。

### 2.1 找到合适的位置

找到 `saveWindowPosition` 函数的上方（大约在第154行附近），添加新函数：

```typescript
// 检测窗口位置并更新布局模式
const updateLayoutMode = async () => {
  try {
    const win = getCurrentWindow();
    const pos = await win.outerPosition();
    const size = await win.outerSize();
    const monitor = await currentMonitor();

    if (monitor) {
      const factor = monitor.scaleFactor;
      // 窗口中心点的逻辑坐标
      const windowCenterX = (pos.x + size.width / 2) / factor;
      const windowCenterY = (pos.y + size.height / 2) / factor;

      // 屏幕中心点
      const screenCenterX = monitor.size.width / factor / 2;
      const screenCenterY = monitor.size.height / factor / 2;

      // 判断窗口在屏幕的哪个象限
      const isLeft = windowCenterX < screenCenterX;
      const isTop = windowCenterY < screenCenterY;

      if (isLeft && isTop) {
        layoutMode.value = 'left-top';
      } else if (!isLeft && isTop) {
        layoutMode.value = 'right-top';
      } else if (isLeft && !isTop) {
        layoutMode.value = 'left-bottom';
      } else {
        layoutMode.value = 'right-bottom';
      }

      console.log('Layout mode updated:', layoutMode.value);
    }
  } catch (err) {
    console.error('Failed to update layout mode:', err);
  }
};
```

### 解释一下

这个函数做了什么呢？让我们拆解来看：

1. **获取窗口位置和大小**
   ```typescript
   const pos = await win.outerPosition();  // 窗口左上角的位置
   const size = await win.outerSize();      // 窗口的宽度和高度
   ```

2. **计算窗口的中心点**
   ```typescript
   const windowCenterX = (pos.x + size.width / 2) / factor;
   const windowCenterY = (pos.y + size.height / 2) / factor;
   ```
   想象一下：窗口左上角在 (100, 200)，宽度是 200，那么中心点的 X 就是 100 + 200/2 = 200

3. **获取屏幕的中心点**
   ```typescript
   const screenCenterX = monitor.size.width / factor / 2;
   const screenCenterY = monitor.size.height / factor / 2;
   ```

4. **判断窗口在哪个象限**
   ```typescript
   const isLeft = windowCenterX < screenCenterX;  // 窗口中心在屏幕中心的左边吗？
   const isTop = windowCenterY < screenCenterY;   // 窗口中心在屏幕中心的上边吗？
   ```

5. **根据象限设置布局模式**
   - 左边 + 上边 = left-top
   - 右边 + 上边 = right-top
   - 左边 + 下边 = left-bottom
   - 右边 + 下边 = right-bottom

---

## 第三步：在关键时刻调用布局检测

我们需要在两个时刻更新布局：
1. 窗口位置恢复后
2. 保存窗口位置时

### 3.1 修改 saveWindowPosition 函数

找到 `saveWindowPosition` 函数，在保存位置后添加布局更新：

```typescript
// 保存窗口位置
const saveWindowPosition = async () => {
  try {
    const win = getCurrentWindow();
    const pos = await win.outerPosition();
    const monitor = await currentMonitor();

    if (monitor) {
      const factor = monitor.scaleFactor;
      const logicalX = pos.x / factor;
      const logicalY = pos.y / factor;

      await store.set('key_visualizer_position', { x: logicalX, y: logicalY });
      await store.save();
      console.log('Window position saved (Logical):', { x: logicalX, y: logicalY });

      // 更新布局模式 <-- 添加这一行！
      await updateLayoutMode();
    }
  } catch (err) {
    console.error('Failed to save window position:', err);
  }
};
```

### 3.2 修改 restoreWindowPosition 函数

找到 `restoreWindowPosition` 函数，在恢复位置后添加布局更新：

```typescript
// 恢复窗口位置
const restoreWindowPosition = async () => {
  try {
    const savedPos = await store.get<{x: number, y: number}>('key_visualizer_position');
    if (savedPos && typeof savedPos.x === 'number' && typeof savedPos.y === 'number') {
      const win = getCurrentWindow();
      await win.setPosition(new LogicalPosition(savedPos.x, savedPos.y));
      console.log('Window position restored:', savedPos);
    } else {
      await updateWindowPosition();
    }
    // 恢复位置后更新布局模式 <-- 添加这一行！
    await updateLayoutMode();
  } catch (err) {
    console.error('Failed to restore window position:', err);
    await updateWindowPosition();
    await updateLayoutMode();  // <-- 这里也要添加！
  }
};
```

---

## 第四步：实时更新布局（拖动时）

现在布局只在保存/恢复时更新。但我们希望拖动窗口时就能看到布局变化，这样更直观！

### 4.1 添加监听器变量

找到文件开头的变量声明区域：

```typescript
let unlisten: (() => void) | null = null;
let unlistenConfig: (() => void) | null = null;
```

在下面添加一行：

```typescript
let unlistenMove: (() => void) | null = null;
```

### 4.2 监听窗口移动事件

在 `onMounted` 函数中，找到监听重置位置事件的代码：

```typescript
// 监听重置位置事件
await listen('reset-key-visualizer-position', async () => {
  console.log('Resetting window position...');
  await updateWindowPosition();
  await saveWindowPosition();
});
```

在它的下面，添加：

```typescript
// 监听窗口移动事件，实时更新布局模式
unlistenMove = await win.onMoved(async () => {
  await updateLayoutMode();
});
```

### 4.3 清理监听器

找到 `onUnmounted` 函数：

```typescript
onUnmounted(() => {
  if (unlisten) unlisten();
  if (unlistenConfig) unlistenConfig();
});
```

添加对新监听器的清理：

```typescript
onUnmounted(() => {
  if (unlisten) unlisten();
  if (unlistenConfig) unlistenConfig();
  if (unlistenMove) unlistenMove();  // <-- 添加这一行！
});
```

### 解释一下

- `win.onMoved()` 是 Tauri 提供的 API，每当窗口移动时都会触发
- 我们在窗口移动时调用 `updateLayoutMode()`，这样布局就会实时更新
- 在组件销毁时要记得清理监听器，否则会造成内存泄漏

---

## 第五步：修改模板，让布局生效

现在我们有了 `layoutMode` 变量，但模板还没有使用它。让我们来修改模板！

### 5.1 修改根容器

找到模板部分的根容器：

```html
<div class="h-full w-full flex flex-col-reverse items-end p-0 overflow-hidden transition-colors duration-300 relative"
  :class="{
    'bg-black border-2 border-dashed border-yellow-400 pointer-events-auto': isEditMode,
    'bg-transparent pointer-events-none': !isEditMode
  }">
```

把它改成：

```html
<div class="h-full w-full flex p-0 overflow-hidden transition-colors duration-300 relative"
  :class="[
    // 编辑模式样式
    isEditMode ? 'bg-black border-2 border-dashed border-yellow-400 pointer-events-auto' : 'bg-transparent pointer-events-none',
    // 纵向方向：bottom 模式从下往上 (flex-col-reverse)，top 模式从上往下 (flex-col)
    layoutMode.includes('bottom') ? 'flex-col-reverse' : 'flex-col',
    // 横向对齐：left 靠左 (items-start)，right 靠右 (items-end)
    layoutMode.includes('left') ? 'items-start' : 'items-end'
  ]">
```

### 解释一下

- `layoutMode.includes('bottom')` 检查当前模式是否包含 "bottom"
  - 如果是 bottom 模式，用 `flex-col-reverse`（从下往上排列）
  - 如果是 top 模式，用 `flex-col`（从上往下排列）
- `layoutMode.includes('left')` 检查当前模式是否包含 "left"
  - 如果是 left 模式，用 `items-start`（靠左对齐）
  - 如果是 right 模式，用 `items-end`（靠右对齐）

### 5.2 修改 TransitionGroup

找到按键列表的 TransitionGroup：

```html
<TransitionGroup name="list" tag="div"
  class="flex flex-col-reverse items-end w-full z-10 pointer-events-none pb-2 pr-2">
```

把它改成：

```html
<TransitionGroup :name="layoutMode.includes('bottom') ? 'list-bottom' : 'list-top'" tag="div"
  class="flex w-full z-10 pointer-events-none"
  :class="[
    // 纵向方向
    layoutMode.includes('bottom') ? 'flex-col-reverse' : 'flex-col',
    // 横向对齐
    layoutMode.includes('left') ? 'items-start' : 'items-end',
    // 内边距：根据位置调整
    layoutMode.includes('bottom') ? 'pb-2' : 'pt-2',
    layoutMode.includes('left') ? 'pl-2' : 'pr-2'
  ]">
```

### 解释一下

- `:name` 动态设置动画名称，bottom 用 `list-bottom`，top 用 `list-top`
- 内边距也是动态的：
  - bottom 模式：按键靠近底部，所以用 `pb-2`（底部内边距）
  - top 模式：按键靠近顶部，所以用 `pt-2`（顶部内边距）
  - left 模式：用 `pl-2`（左侧内边距）
  - right 模式：用 `pr-2`（右侧内边距）

---

## 第六步：添加对应的动画样式

最后，我们需要为两种布局方向添加不同的动画效果。

### 6.1 替换原有的样式

找到文件底部的 `<style scoped>` 部分，把原来的样式：

```css
<style scoped>
.list-move,
.list-enter-active,
.list-leave-active {
  transition: all 0.3s ease;
}

.list-enter-from {
  opacity: 0;
  transform: translateY(20px);
}

.list-leave-to {
  opacity: 0;
  transform: translateY(-20px);
}

.list-leave-active {
  position: absolute;
}
</style>
```

替换为：

```css
<style scoped>
/* 从下往上布局的动画 (bottom 模式) */
.list-bottom-move,
.list-bottom-enter-active,
.list-bottom-leave-active {
  transition: all 0.3s ease;
}

.list-bottom-enter-from {
  opacity: 0;
  transform: translateY(20px);
}

.list-bottom-leave-to {
  opacity: 0;
  transform: translateY(-20px);
}

.list-bottom-leave-active {
  position: absolute;
}

/* 从上往下布局的动画 (top 模式) */
.list-top-move,
.list-top-enter-active,
.list-top-leave-active {
  transition: all 0.3s ease;
}

.list-top-enter-from {
  opacity: 0;
  transform: translateY(-20px);
}

.list-top-leave-to {
  opacity: 0;
  transform: translateY(20px);
}

.list-top-leave-active {
  position: absolute;
}
</style>
```

### 解释一下

两种动画的区别在于方向：

**Bottom 模式（从下往上）：**
- 新按键从下方（+20px）滑入
- 旧按键向上方（-20px）滑出

**Top 模式（从上往下）：**
- 新按键从上方（-20px）滑入
- 旧按键向下方（+20px）滑出

这样动画方向就和布局方向一致了！

---

## 完成！

恭喜你！现在按键显示窗口会根据它在屏幕上的位置，自动调整：

1. **显示方向**：上半屏从上往下显示，下半屏从下往上显示
2. **对齐方式**：左半屏靠左对齐，右半屏靠右对齐
3. **动画效果**：动画方向与布局方向一致
4. **实时更新**：拖动窗口时立即看到变化

## 效果演示

| 窗口位置 | 布局效果 |
|---------|---------|
| 左上角 | 按键从顶部向下排列，靠左显示 |
| 右上角 | 按键从顶部向下排列，靠右显示 |
| 左下角 | 按键从底部向上排列，靠左显示 |
| 右下角 | 按键从底部向上排列，靠右显示 |

---

## 小贴士

如果你想添加更多的布局模式（比如左中、右中、上中、下中），可以：

1. 在 `LayoutMode` 类型中添加新的模式名称
2. 在 `updateLayoutMode` 函数中添加新的判断逻辑
3. 在模板中处理新的布局样式

这个功能的核心思想是：**根据窗口位置动态调整 UI**，这个思路可以应用到很多其他场景！
