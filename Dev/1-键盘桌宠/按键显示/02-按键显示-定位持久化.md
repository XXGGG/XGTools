# 按键显示-定位持久化

我们需要在“主界面（桌宠设置）”控制“副界面（按键显示）”的状态，并利用 `tauri-plugin-store` 保存设置。

## 跨窗口通信与持久化

### 安装 `tauri-plugin-store`
```
pnpm add @tauri-apps/plugin-store
```

### 在 `src-tauri/Cargo.toml` 中添加依赖：
```toml
[dependencies]
# ....
tauri-plugin-store = "2" # 用于持久化存储
``` 

### 引入 Store
确保安装了 store 插件并在 `src-tauri/src/lib.rs` 中注册。
```rust
tauri::Builder::default()
    .plugin(tauri_plugin_store::Builder::new().build()) // 添加这一行
    .setup(|app| { 
        // ... 
        Ok(()) 
    })
```

### 添加权限 (src-tauri/capabilities/default.json)
必须授权前端访问 store，否则 new LazyStore 会权限报错：
```json
"permissions": [
  "store:default"
]
```

## 前端使用 `LazyStore`：

```typescript
import { LazyStore } from '@tauri-apps/plugin-store';
const store = new LazyStore('settings.json');
```
### 主窗口 (`App.vue`)
打开应用的时候要记录之前是否有打开：
```typescript
//...
import { WebviewWindow } from '@tauri-apps/api/webviewWindow';// 引入 WebviewWindow 用于创建窗口
import { emit } from '@tauri-apps/api/event'; // 引入 emit 用于事件通信
import { LazyStore } from '@tauri-apps/plugin-store'; // 引入 Store

// 定义是否显示键盘可视化窗口
const isKeyVisualizer = ref(false);

onMounted(async () => {
  const win = getCurrentWindow(); // 获取当前窗口实例
  if (win.label === 'key_visualizer') {
    isKeyVisualizer.value = true;
    return; // 如果是副窗口，就只做副窗口该做的事
  }

  // 初始化 Store
  const store = new LazyStore('settings.json');
  await store.init();

  // --- 恢复按键显示窗口状态 ---
  try {
    // 1. 从 Store 中获取之前 key_visualizer_enabled 的状态
    const savedKeyVisState = await store.get<boolean>('key_visualizer_enabled');
    const isKeyVisOpen = ref(false); // 临时变量用于逻辑判断

    // 检查当前窗口是否存在
    let win = await WebviewWindow.getByLabel('key_visualizer');
    if (win) {
      isKeyVisOpen.value = await win.isVisible();
    }

    if (savedKeyVisState && !isKeyVisOpen.value) {
      if (!win) {
        // 动态创建窗口
        win = new WebviewWindow('key_visualizer', {
          url: 'index.html',
          title: '',
          width: 270,
          height: 300,
          decorations: false,
          shadow: false,
          transparent: true,
          alwaysOnTop: true,
          skipTaskbar: true,
          resizable: false,
          visible: true
        });

        // 确保新建窗口处于非编辑模式
        await emit('toggle-key-visualizer-edit', false);
      } else {
        await win.show();
        await win.setFocus();
        await emit('toggle-key-visualizer-edit', false);
      }
    }
  } catch (err) {
    console.error('Failed to restore Key Visualizer state:', err);
  }
});
```

### 【桌宠页面】逻辑 (`KeyboardPet.vue`)
负责开关状态的持久化。

```typescript
// 引入 store 插件
import { LazyStore } from '@tauri-apps/plugin-store';
const store = new LazyStore('settings.json');

//...

// 初始化时恢复状态
const checkWindowState = async () => {
    // 1. 初始化 store
    await store.init();

    // 2. 获取保存的配置
    const savedState = await store.get<boolean>('key_visualizer_enabled');

    // 3. 检查当前窗口是否真的存在
    const win = await WebviewWindow.getByLabel('key_visualizer');
    if (win) {
        isKeyVisOpen.value = await win.isVisible();
    }

    // 4. 如果配置是开启的，但窗口没开 (比如应用刚启动)，则自动开启
    if (savedState && !isKeyVisOpen.value) {
        await toggleKeyVis();
    }
};

onMounted(() => {
    checkWindowState();
});

//...
// 切换按键可视化窗口
const toggleKeyVis = async () => {
    try {
        let win = await WebviewWindow.getByLabel('key_visualizer');

        if (!win) {
            // 动态创建窗口
            win = new WebviewWindow('key_visualizer', {
                url: 'index.html',
                title: 'key_visualizer',
                width: 270,
                height: 300,
                decorations: false,
                shadow: false,
                transparent: true,
                alwaysOnTop: true,
                skipTaskbar: true,
                resizable: false,
                visible: true
            });

            // 监听创建错误
            win.once('tauri://error', (e) => {
                console.error('Failed to create window:', e);
                alert('无法创建按键显示窗口，请尝试重启应用。' + JSON.stringify(e));
            });

            // 监听创建完成事件
            win.once('tauri://created', () => {
                console.log('[Pet.vue] Window created event received');
            });

            // 重置编辑模式
            isEditMode.value = false;
            // 同步编辑模式到窗口
            await emit('toggle-key-visualizer-edit', false);

            // 窗口打开状态
            isKeyVisOpen.value = true;
            // 保存状态
            await store.set('key_visualizer_enabled', true);
            await store.save();
            return;
        }

        // 如果窗口可见
        if (isKeyVisOpen.value) {
            // 那么久把窗口关闭
            await win.hide();
            isKeyVisOpen.value = false;

            // 关闭时也重置编辑模式
            isEditMode.value = false;
            await emit('toggle-key-visualizer-edit', false);

            // 保存状态
            await store.set('key_visualizer_enabled', false);
            await store.save();
        } else {
            // 否则窗口就打开
            await win.show();
            isKeyVisOpen.value = true;
            // await win.setFocus(); // 确保窗口获得焦点
            // await win.center(); // 强制居中，防止跑偏 (已移除，避免影响位置恢复)

            // 窗口打开时默认关闭编辑模式
            isEditMode.value = false;
            await emit('toggle-key-visualizer-edit', false);

            
            // 调试提示
            const isVisible = await win.isVisible();
            if (!isVisible) {
                alert('警告：窗口已调用 show() 但 isVisible 仍为 false。请检查 tauri.conf.json 配置。');
            }

            // 保存状态
            await store.set('key_visualizer_enabled', true);
            await store.save();
        }
    } catch (error) {
        console.error('Toggle error:', error);
        alert('操作失败: ' + String(error));
    }
};
```

### 【按键显示窗口】逻辑 (`KeyVisualizerWindow.vue`)

```typescript
// 引入 store 插件
onMounted(async () => {

    // 初始化 Store
    await store.init();

    // 强制设置透明背景
    //...

    // 恢复位置
    await restoreWindowPosition();

    // 监听配置变更事件
    unlistenConfig = await listen('toggle-key-visualizer-edit', async (event: any) => {
        const enabled = event.payload;
        isEditMode.value = enabled;
        // 如果是编辑模式，不忽略鼠标 (可以点击/拖拽)
        // 如果是正常模式，忽略鼠标 (穿透)
        await win.setIgnoreCursorEvents(!enabled);

        if (enabled) {
            // 编辑模式下，显示并置顶，确保用户能看到
            await win.show();
            await win.setFocus();
        } else {
            // 退出编辑模式时，保存位置
            await saveWindowPosition(); //添加这一行，确保退出编辑模式时保存位置
        }
    });

    // 监听重置位置事件
    await listen('reset-key-visualizer-position', async () => {
        console.log('Resetting window position...');
        await updateWindowPosition(); // Reset to default (bottom-right)
        await saveWindowPosition();   // Save new default position
    });


    // 监听输入事件
    unlisten = await listen<InputPayload>('input-event', (event) => {
        // console.log('Received input-event:', event.payload); // 打印原始事件
        // event_type: KeyPress/KeyRelease/ButtonPress
        // key: 原始按键名称 (如 KeyA, KeyF1, Digit0, etc.)
        const { event_type, key } = event.payload; 
        // 转换为显示名称 (如 KeyA -> A, KeyF1 -> F1, Digit0 -> 0)
        const displayName = getDisplayName(key);

        
        // 按键事件处理 KeyPress 意思是【按键按下】
        if (event_type === 'KeyPress') {
            // 【处理组合按钮，例如 Ctrl+A，Ctrl+Alt+A】
            if (isModifier(displayName)) {
                // 修饰键（Ctrl/Shift/Alt/Win）按下
                // 只在首次按下时添加到 activeModifiers
                if (!activeModifiers.value.has(displayName)) {
                    activeModifiers.value.add(displayName);
                    modifierDirty.value[displayName] = false; // 只有首次按下重置状态
                }
            } else {
                // 普通按键按下
                // 标记所有当前按下的修饰键为 dirty (已使用)
                activeModifiers.value.forEach(m => modifierDirty.value[m] = true);

                // 构建组合字符串
                // 顺序：Ctrl -> Shift -> Alt -> Win -> Key
                const combo: string[] = [];
                if (activeModifiers.value.has('Ctrl')) combo.push('Ctrl');
                if (activeModifiers.value.has('Shift')) combo.push('Shift');
                if (activeModifiers.value.has('Alt')) combo.push('Alt');
                if (activeModifiers.value.has('Win')) combo.push('Win');

                combo.push(displayName); //最后连接普通按键
                addKeyToDisplay(combo.join(' + '));//用 + 号连接，例如：Ctrl + A
            }
        } else if (event_type === 'KeyRelease') {//【处理按键释放事件】
            if (isModifier(displayName)) { //如果是修饰键
                // 如果修饰键释放，且期间没有被使用过（没有与其他键组合），则单独显示
                if (modifierDirty.value[displayName] === false) {
                    addKeyToDisplay(displayName);
                }
                activeModifiers.value.delete(displayName);
                delete modifierDirty.value[displayName];
            }
        } else if (event_type === 'ButtonPress') {//【处理鼠标按键事件】
            // 鼠标按键
            let mouseKey = key;
            if (key === 'Left') mouseKey = '左键';
            if (key === 'Right') mouseKey = '右键';
            if (key === 'Middle') mouseKey = '中键';

            // 鼠标也可以配合修饰键
            const combo: string[] = [];
            if (activeModifiers.value.has('Ctrl')) combo.push('Ctrl');
            if (activeModifiers.value.has('Shift')) combo.push('Shift');
            if (activeModifiers.value.has('Alt')) combo.push('Alt');
            if (activeModifiers.value.has('Win')) combo.push('Win');

            combo.push(mouseKey);
            addKeyToDisplay(combo.join(' + '));
        }
    });
});

// 组件卸载时，移除事件监听
onUnmounted(() => {
    if (unlisten) unlisten(); //移除输入事件监听
    if (unlistenConfig) unlistenConfig(); //移除配置变更事件监听
});
```


```typescript
//...
import { getCurrentWindow, currentMonitor, LogicalPosition } from '@tauri-apps/api/window';


// 保存窗口位置
const saveWindowPosition = async () => {
    try {
        const win = getCurrentWindow();
        const pos = await win.outerPosition(); // Returns PhysicalPosition
        const monitor = await currentMonitor();

        if (monitor) {
            const factor = monitor.scaleFactor;
            // 转换为逻辑坐标保存，防止 DPI 缩放导致的偏移
            const logicalX = pos.x / factor;
            const logicalY = pos.y / factor;

            await store.set('key_visualizer_position', { x: logicalX, y: logicalY });
            await store.save();
            console.log('Window position saved (Logical):', { x: logicalX, y: logicalY });

            // 更新布局模式
            await updateLayoutMode();
        }
    } catch (err) {
        console.error('Failed to save window position:', err);
    }
};

// 恢复窗口位置
const restoreWindowPosition = async () => {
    try {
        const savedPos = await store.get<{ x: number, y: number }>('key_visualizer_position');
        if (savedPos && typeof savedPos.x === 'number' && typeof savedPos.y === 'number') {
            const win = getCurrentWindow();
            await win.setPosition(new LogicalPosition(savedPos.x, savedPos.y));
            console.log('Window position restored:', savedPos);
        } else {
            // 如果没有保存的位置，使用默认位置 (右下角)
            await updateWindowPosition();
        }
        // 恢复位置后更新布局模式
        await updateLayoutMode();
    } catch (err) {
        console.error('Failed to restore window position:', err);
        await updateWindowPosition(); // Fallback to default
        await updateLayoutMode();
    }
};

onMounted(async () => {
  //...
})
```

```typescript
// 检测窗口位置并更新布局模式
const updateLayoutMode = async () => {
  try {
    const win = getCurrentWindow();
    const pos = await win.outerPosition();
    const size = await win.outerSize();
    const monitor = await currentMonitor();

    if (monitor) {
      const factor = monitor.scaleFactor;
      // 窗口中心点的逻辑坐标
      const windowCenterX = (pos.x + size.width / 2) / factor;
      const windowCenterY = (pos.y + size.height / 2) / factor;

      // 屏幕中心点
      const screenCenterX = monitor.size.width / factor / 2;
      const screenCenterY = monitor.size.height / factor / 2;

      // 判断窗口在屏幕的哪个象限
      const isLeft = windowCenterX < screenCenterX;
      const isTop = windowCenterY < screenCenterY;

      if (isLeft && isTop) {
        layoutMode.value = 'left-top';
      } else if (!isLeft && isTop) {
        layoutMode.value = 'right-top';
      } else if (isLeft && !isTop) {
        layoutMode.value = 'left-bottom';
      } else {
        layoutMode.value = 'right-bottom';
      }

      console.log('Layout mode updated:', layoutMode.value);
    }
  } catch (err) {
    console.error('Failed to update layout mode:', err);
  }
};
```

















## 4. 智能按键逻辑：组合键实现

### 4.1 映射表 (Mapping)
把 `rdev` 的原始键名翻译成人话。

```typescript
const keyMap: Record<string, string> = {
  'ControlLeft': 'Ctrl', 'KeyControlLeft': 'Ctrl',
  'ShiftLeft': 'Shift',  'KeyShiftLeft': 'Shift',
  'Dot': '.', 'KeyDot': '.',
  // ... 更多映射
};
```

### 恢复定位：
`src-tauri/capabilities/default.json`

```json
{
  "$schema": "../gen/schemas/desktop-schema.json",
  "identifier": "default",
  "description": "Capability for the main window",
  "windows": ["main","key_visualizer"],
  "permissions": [
    "core:default",
    "opener:default",
    "core:window:allow-set-size",     // <--- 添加这一行，允许调整窗口大小
    "core:window:allow-set-position", // <--- 既然是 resetPosition，通常也需要这个
  ]
}
```
#### KeyboardPet 按键显示
```typescript
import { LogicalSize } from '@tauri-apps/api/window';

// 重置窗口位置
const resetWindowPosition = async () => {
    try {
        const win = await WebviewWindow.getByLabel('key_visualizer');
        if (win) {
            // 1. 检查是否被最小化，如果是则恢复
            if (await win.isMinimized()) {
                await win.unminimize();
            }

            // 2. 确保窗口可见
            if (!(await win.isVisible())) {
                await win.show();
            }

            // 3. 强制恢复默认尺寸 (270x300)
            await win.setSize(new LogicalSize(270, 300));

            // 4. 发送重置位置事件 (让窗口自己移动到右下角)
            await emit('reset-key-visualizer-position');
        }
    } catch (error) {
        console.error('Failed to reset position:', error);
    }
};
```
#### 在 KeyVisualizer.vue 中添加恢复定位逻辑的监听
```typescript
onMounted(async () => {
  // 监听重置位置事件
  await listen('reset-key-visualizer-position', async () => {
      console.log('Resetting window position...');
      await updateWindowPosition(); // 恢复默认位置
      await saveWindowPosition();   // 保存新位置
  });
})
```
