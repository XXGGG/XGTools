# 按键显示-按键自动清除（最佳实践）

本教程将教你如何实现一个优雅的按键自动清除功能。当用户停止输入一段时间后，显示的按键会自动消失，避免屏幕上堆积过多的历史按键信息。

---

## 📋 功能需求

1. **用户可控开关**：在键盘桌宠设置页面添加一个开关按钮，让用户决定是否启用自动清除功能
2. **智能定时器**：只在有按键输入时才启动定时器，避免"空转"浪费资源
3. **持久化配置**：使用 Store 保存用户的偏好设置，下次打开应用时自动恢复
4. **视觉反馈**：按钮状态要清晰，让用户一眼就能看出当前是否开启了自动清除

---

## 第一部分：CSS 过渡动画定位调整

### 1.1 为什么要调整定位？

在 Vue 的 `TransitionGroup` 组件中，通常推荐给"正在离开"的元素设置 `position: absolute`（绝对定位），这样元素会脱离文档流，让其他元素能够平滑地移动到新位置（触发 `v-move` 动画）。

但在某些情况下，绝对定位会导致：
- **布局瞬间坍塌**：元素突然脱离文档流，其他元素瞬间跳到新位置
- **元素重叠**：正在消失的元素和移动的元素重叠在一起

使用 `position: relative`（相对定位）可以让元素在动画过程中**仍然占据原来的空间**，直到动画完全结束才释放空间，从而获得更平滑的视觉效果。

### 1.2 修改步骤

**代码位置**：`src/KeyVisualizerWindow.vue` 文件底部的 `<style>` 标签内

找到以下两个 CSS 类：

```css
.list-bottom-leave-active {
  /* position: absolute; */
  position: relative;  /* 修改为相对定位 */
}

.list-top-leave-active {
  position: relative;  /* 修改为相对定位 */
}
```

**专业名词解释**：
- **TransitionGroup**：Vue 提供的列表过渡组件，用于给多个元素的进入/离开添加动画效果
- **leave-active**：元素正在执行"离开"动画的状态类名
- **文档流**：HTML 元素在页面上的正常排列顺序，绝对定位的元素会脱离文档流

---

## 第二部分：优化定时器逻辑（核心改进）

### 2.1 原有代码的问题

原来的代码是这样的：

```typescript
// ❌ 问题代码：定时器一直在运行，即使没有按键
const clearTimer = setInterval(() => {
  if (keys.value.length > 0) {
    const lastKey = keys.value[keys.value.length - 1];
    if (Date.now() - lastKey.timestamp > 3000) {
      keys.value.pop();
    }
  }
}, 500);
```

**存在的问题**：
- 定时器在组件加载时就启动了，即使用户没有按任何键
- 当 `keys.value` 为空时，定时器每 500ms 检查一次，但什么也不做（"空转"）
- 浪费计算资源，不够优雅

### 2.2 最佳实践方案

**核心思想**：
1. **按需启动**：只在有按键输入时才启动定时器
2. **自动停止**：当所有按键都清除完毕后，自动停止定时器
3. **开关控制**：用户可以通过配置开关决定是否启用此功能

### 2.3 具体实现步骤

#### 步骤 1：在 `KeyVisualizerWindow.vue` 添加响应式变量

**代码位置**：`src/KeyVisualizerWindow.vue` 的 `<script setup>` 顶部

在现有的响应式变量下方添加：

```typescript
// 是否启用自动清除功能
const isAutoClear = ref(false);

// 定时器引用（用于控制定时器的启动和停止）
// 💡 注意：如果在 TypeScript 中报错 "Type 'Timeout' is not assignable to type 'number'"
// 这是因为 TS 可能使用了 Node.js 的类型定义。
// 最佳实践是使用 ReturnType<typeof setInterval> 来自动适配环境
let clearTimer: ReturnType<typeof setInterval> | null = null;

// 自动清除的延迟时间（毫秒）
const AUTO_CLEAR_DELAY = 3000; // 3秒后自动清除
```

**专业名词解释**：
- **ref**：Vue 3 的响应式引用，用于创建一个可响应的变量
- **ReturnType<typeof setInterval>**：TypeScript 高级类型，自动获取 `setInterval` 函数返回值的类型（在浏览器中是 number，在 Node.js 中是 Timeout），这样写最安全且兼容性最好

#### 步骤 2：创建启动定时器的函数

在 `<script setup>` 中添加以下函数：

```typescript
// 启动自动清除定时器
const startClearTimer = () => {
  // 如果定时器已经在运行，不要重复启动
  if (clearTimer !== null) return;
  
  // 如果功能未开启，不启动定时器
  if (!isAutoClear.value) return;

  // 启动定时器，每 500ms 检查一次
  clearTimer = setInterval(() => {
    if (keys.value.length === 0) {
      // 如果列表已经清空，停止定时器
      stopClearTimer();
      return;
    }

    // 检查最后一个按键是否超时
    const lastKey = keys.value[keys.value.length - 1];
    const timePassed = Date.now() - lastKey.timestamp;

    if (timePassed > AUTO_CLEAR_DELAY) {
      // 移除最后一个按键
      keys.value.pop();
    }
  }, 500);

  console.log('自动清除定时器已启动');
};
```

**代码解析**：
1. **防止重复启动**：如果 `clearTimer` 不为 null，说明定时器已在运行，直接返回
2. **功能开关检查**：如果用户没有开启自动清除功能，不启动定时器
3. **setInterval**：每 500 毫秒执行一次检查
4. **自动停止机制**：当列表为空时，调用 `stopClearTimer()` 停止定时器
5. **时间计算**：`Date.now()` 获取当前时间戳，减去按键的时间戳得到经过的时间

#### 步骤 3：创建停止定时器的函数

```typescript
// 停止自动清除定时器
const stopClearTimer = () => {
  if (clearTimer !== null) {
    clearInterval(clearTimer);
    clearTimer = null;
    console.log('自动清除定时器已停止');
  }
};
```

**代码解析**：
- **clearInterval**：清除由 `setInterval` 创建的定时器
- **设置为 null**：重置变量，方便下次重新启动

#### 步骤 4：在添加按键时触发定时器

找到 `addKeyToDisplay` 函数（大约在第 147 行），在函数末尾添加：

```typescript
const addKeyToDisplay = (displayText: string) => {
  // 原有代码：添加按键到列表
  keys.value.unshift({
    id: nextId++,
    key: displayText,
    timestamp: Date.now()
  });

  if (keys.value.length > MAX_ITEMS) {
    keys.value.pop();
  }

  // ✅ 新增：当有按键输入时，启动自动清除定时器
  startClearTimer();
};
```

**代码解析**：
- 每次有新按键输入时，调用 `startClearTimer()`
- 如果定时器已经在运行，函数内部会自动跳过，不会重复启动
- 这样就实现了"按需启动"的效果

#### 步骤 5：监听配置变化

在 `onMounted` 函数中添加以下代码（找到现有的 `listen` 调用，在附近添加）：

```typescript
onMounted(async () => {
  // ... 原有代码 ...

  // ✅ 新增：恢复自动清除配置
  isAutoClear.value = await store.get('auto_clear_enabled') || false;
  console.log('自动清除功能状态:', isAutoClear.value);

  // ✅ 新增：监听自动清除配置变更
  const unlistenAutoClear = await listen('toggle-auto-clear', async (event: any) => {
    const enabled = event.payload;
    isAutoClear.value = enabled;

    if (enabled) {
      // 如果开启了自动清除，且当前有按键，立即启动定时器
      if (keys.value.length > 0) {
        startClearTimer();
      }
    } else {
      // 如果关闭了自动清除，停止定时器
      stopClearTimer();
    }
  });

  // ... 原有代码 ...
});
```

**专业名词解释**：
- **LazyStore**：Tauri 提供的轻量级存储插件，用于保存应用配置
- **listen**：监听自定义事件，实现跨窗口通信
- **event.payload**：事件携带的数据，这里是布尔值（true/false）

#### 步骤 6：在组件卸载时清理

找到 `onUnmounted` 函数，确保添加了定时器清理：

```typescript
onUnmounted(() => {
  if (unlisten) unlisten();
  if (unlistenConfig) unlistenConfig();
  if (unlistenMove) unlistenMove();
  if (unlistenAvoidMouse) unlistenAvoidMouse();
  
  // ✅ 确保有这一行：清理自动清除定时器
  stopClearTimer();
});
```

---

## 第三部分：添加控制开关（KeyboardPet.vue）

### 3.1 添加响应式状态

**代码位置**：`src/views/KeyboardPet.vue` 的 `<script setup>` 顶部

在现有的 `ref` 变量下方添加：

```typescript
const isAutoClear = ref(false); // 是否启用自动清除
```

### 3.2 在 `checkWindowState` 函数中恢复配置

找到 `checkWindowState` 函数，在末尾添加：

```typescript
const checkWindowState = async () => {
  // ... 原有代码 ...

  // ✅ 新增：恢复自动清除配置
  isAutoClear.value = await store.get<boolean>('auto_clear_enabled') || false;
};
```

### 3.3 创建切换函数

在 `toggleAvoidMouse` 函数下方添加新函数：

```typescript
// 切换自动清除
const toggleAutoClear = async () => {
  isAutoClear.value = !isAutoClear.value;
  
  // 发送事件到 KeyVisualizerWindow
  await emit('toggle-auto-clear', isAutoClear.value);
  
  // 保存配置到 store
  await store.set('auto_clear_enabled', isAutoClear.value);
  await store.save();
  
  console.log('自动清除功能:', isAutoClear.value ? '已开启' : '已关闭');
};
```

**代码解析**：
1. **切换状态**：`!isAutoClear.value` 实现开关效果（true 变 false，false 变 true）
2. **发送事件**：通知 `KeyVisualizerWindow.vue` 更新状态
3. **保存配置**：将用户选择持久化保存，下次打开应用自动恢复

### 3.4 添加按钮到界面

**代码位置**：`src/views/KeyboardPet.vue` 的 `<template>` 部分

找到"躲避按钮"的代码，在它**之前**添加自动清除按钮：

```vue
<div class="flex items-center gap-2">
  <!-- ✅ 新增：自动清除按钮 (在躲避按钮之前) -->
  <button 
    v-if="isKeyVisOpen" 
    @click="toggleAutoClear" 
    class="flex p-2 rounded-lg transition-colors"
    :class="isAutoClear 
      ? 'bg-blue-500 text-white hover:bg-blue-600' 
      : 'hover:bg-accent text-muted-foreground hover:text-foreground'"
    title="自动清除">
    <span class="icon-[lucide--eraser] w-6 h-6" />
  </button>

  <!-- 原有的躲避按钮 -->
  <button v-if="isKeyVisOpen" @click="toggleAvoidMouse" ...>
    ...
  </button>

  <!-- ... 其他按钮 ... -->
</div>
```

**UI 设计说明**：
- **图标选择**：使用 `lucide--eraser`（橡皮擦）图标，直观表达"清除"的含义
- **颜色方案**：
  - 开启状态：蓝色背景 (`bg-blue-500`)，白色图标
  - 关闭状态：灰色图标，悬停时高亮
- **条件显示**：`v-if="isKeyVisOpen"` 确保只在窗口打开时显示按钮
- **按钮位置**：放在"躲避鼠标"按钮之前，符合从左到右的操作逻辑顺序

---

## 第四部分：工作原理详解

### 4.1 整体流程图

```
用户按键 
  ↓
addKeyToDisplay() 添加按键到列表
  ↓
startClearTimer() 检查并启动定时器
  ↓
定时器每 500ms 检查一次
  ↓
最后一个按键超过 3 秒？
  ├─ 是 → 移除按键 → 列表为空？
  │                    ├─ 是 → stopClearTimer() 停止定时器
  │                    └─ 否 → 继续检查
  └─ 否 → 继续等待
```

### 4.2 关键技术点

#### 1. 时间戳机制

每个按键对象包含 `timestamp` 字段，记录按键被添加的时间：

```typescript
interface KeyItem {
  id: number;
  key: string;
  timestamp: number;  // 记录创建时间（毫秒）
}
```

通过 `Date.now() - lastKey.timestamp` 计算按键已经显示了多久。

#### 2. 定时器的启动与停止

- **启动时机**：有新按键输入，且定时器未运行
- **停止时机**：按键列表清空，或用户关闭功能
- **防重复**：通过 `clearTimer !== null` 判断避免重复启动

#### 3. 事件通信机制

使用 Tauri 的事件系统实现跨窗口通信：

```typescript
// KeyboardPet.vue（主窗口）发送事件
await emit('toggle-auto-clear', true);

// KeyVisualizerWindow.vue（子窗口）接收事件
await listen('toggle-auto-clear', (event) => {
  isAutoClear.value = event.payload;
});
```

---

## 第五部分：测试与验证

### 5.1 功能测试清单

完成代码后，按照以下步骤测试功能：

1. **基础功能测试**
   - [ ] 打开按键显示窗口
   - [ ] 点击"自动清除"按钮，确认按钮变为蓝色
   - [ ] 按几个键，等待 3 秒，确认按键自动消失
   - [ ] 再次点击按钮关闭功能，按键后等待 3 秒，确认不会自动消失

2. **性能测试**
   - [ ] 打开开发者工具的控制台
   - [ ] 关闭自动清除功能
   - [ ] 不按任何键，观察控制台是否有"自动清除定时器已启动"的日志（应该没有）
   - [ ] 开启自动清除功能
   - [ ] 按一个键，观察是否出现"已启动"日志
   - [ ] 等待所有按键清除完毕，观察是否出现"已停止"日志

3. **持久化测试**
   - [ ] 开启自动清除功能
   - [ ] 完全关闭应用并重新打开
   - [ ] 确认"自动清除"按钮仍为蓝色（开启状态）
   - [ ] 按键后确认自动清除生效

4. **边界情况测试**
   - [ ] 快速连续输入多个按键，确认定时器不会重复启动
   - [ ] 在按键即将消失时（2.9秒）再按一个新键，确认旧键仍会正常消失

### 5.2 常见问题排查

**问题 1：按钮点击后没有反应**
- 检查 `toggleAutoClear` 函数中的 `console.log` 是否输出
- 检查 `emit` 事件名称是否拼写正确
- 确认 `KeyVisualizerWindow.vue` 中有对应的 `listen` 监听器

**问题 2：按键不会自动消失**
- 检查 `isAutoClear.value` 是否为 true
- 检查定时器是否成功启动（查看控制台日志）
- 确认 `AUTO_CLEAR_DELAY` 的值（建议 3000ms）

**问题 3：关闭功能后按键仍然消失**
- 检查 `stopClearTimer()` 是否被正确调用
- 确认 `clearTimer` 被设置为 null

---

## 第六部分：扩展功能建议

完成基础功能后，你可以尝试以下扩展：

### 6.1 可调节的延迟时间

允许用户自定义清除延迟：

```typescript
// 添加配置项
const autoClearDelay = ref(3000); // 默认 3 秒

// 在界面添加滑块或输入框
<input 
  v-model.number="autoClearDelay" 
  type="range" 
  min="1000" 
  max="10000" 
  step="500"
/>
```

### 6.2 渐进式清除

从最早的按键开始清除，而不是等所有按键一起清除：

```typescript
const clearTimer = setInterval(() => {
  if (keys.value.length === 0) {
    stopClearTimer();
    return;
  }

  // 从后往前检查，清除所有超时的按键
  keys.value = keys.value.filter(key => 
    Date.now() - key.timestamp <= AUTO_CLEAR_DELAY
  );
}, 500);
```

### 6.3 清除动画优化

在清除前添加淡出提示：

```typescript
// 添加一个"即将清除"的状态
const willClearSoon = (timestamp: number) => {
  const remaining = AUTO_CLEAR_DELAY - (Date.now() - timestamp);
  return remaining < 1000 && remaining > 0; // 最后 1 秒
};

// 在模板中使用
<div :class="{ 'animate-pulse': willClearSoon(item.timestamp) }">
  {{ item.key }}
</div>
```

---

## 📚 总结

通过本教程，你学会了：

1. ✅ **优化定时器机制**：按需启动，自动停止，避免资源浪费
2. ✅ **添加用户控制**：让用户决定是否启用自动清除功能
3. ✅ **持久化配置**：使用 Store 保存用户偏好
4. ✅ **跨窗口通信**：使用 Tauri 事件系统同步状态
5. ✅ **界面交互设计**：清晰的按钮状态反馈

**核心设计原则**：
- **性能优先**：定时器只在需要时运行
- **用户体验**：给用户控制权，状态清晰可见
- **代码优雅**：逻辑清晰，易于维护和扩展

现在，你可以按照教程一步步实现这个功能了！如果遇到问题，记得查看控制台日志，它们会帮助你定位问题。加油！💪